# Runs the LLM Security Scan from GitHub Marketplace on tag release.
# Uses AI analysis (max 5 findings) and uploads results to your backend/database.
#
# Tag pattern: push a tag like scan/v1.0.0 or release/scan-1.0.0 to trigger.
#
# Required repository secrets:
#   OPENAI_API_KEY       - For AI analysis (or set ai-api-key and use ANTHROPIC_API_KEY for Anthropic)
#   LLM_SCAN_UPLOAD_ENDPOINT - Backend API URL for uploading results (e.g. https://api.example.com/scans)
#   LLM_SCAN_APPLICATION_ID  - Application ID for the backend
#   LLM_SCAN_API_KEY     - API key for backend authentication

name: LLM Security Scan (Marketplace)

on:
  push:
    branches: [main]
    
    tags:
      # Runs when you push a tag matching these patterns:
      - 'scan/v*.*.*'        # e.g. scan/v1.0.0, scan/v2.1.3
      - 'release/scan-*'     # e.g. release/scan-1.0.0
  workflow_dispatch:
    inputs:
      tag_ref:
        description: 'Ref to scan (branch or tag, e.g. main or v1.0.0)'
        required: false
        type: string
        default: ''

jobs:
  scan:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
      actions: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.tag_ref || github.ref }}
          fetch-depth: 0

      - name: Run LLM Security Scan (Marketplace)
        id: scan
        #uses: spydra-tech/trusys-llm-security-scan-action@main
        uses: spydra-tech/trusys-llm-security-scan-action@v1.0.3
        with:
          python-version: '3.11'
          # Scan only one file in samples (change to your file, e.g. samples/aws/aws_code_injection.py)
          paths: 'samples/azure/azure_code_injection.py'
          exclude: 'tests/**,.github/**,**/__pycache__/**,**/.git/**'
          format: 'sarif'
          no-fail-on-findings: 'true'
          upload-sarif-to-github: 'true'
          # AI analysis: limit to 5 findings
          enable-ai-filter: 'true'
          ai-max-findings: '5'
          ai-provider: 'openai'
          ai-model: 'gpt-4'
          ai-api-key: ${{ secrets.OPENAI_API_KEY }}
          ai-confidence-threshold: '0.7'
          # Push results to database/backend
          upload-endpoint: ${{ secrets.LLM_SCAN_UPLOAD_ENDPOINT }}
          application-id: ${{ secrets.LLM_SCAN_APPLICATION_ID }}
          api-key: ${{ secrets.LLM_SCAN_API_KEY }}

      
      
      - name: Resolve target ref/sha
        id: target
        shell: bash
        run: |
          set -euo pipefail
          SHA="$(git rev-parse HEAD)"
          DEFAULT_BRANCH="${{ github.event.repository.default_branch }}"

          # Ensure we have the default branch tip locally
          git fetch origin "${DEFAULT_BRANCH}" --depth=1 || true

          # If the scanned SHA is reachable from default branch, upload results to default branch
          if git merge-base --is-ancestor "${SHA}" "origin/${DEFAULT_BRANCH}"; then
            echo "ref=refs/heads/${DEFAULT_BRANCH}" >> "$GITHUB_OUTPUT"
            echo "sha=${SHA}" >> "$GITHUB_OUTPUT"
          else
            # Fallback: upload to the tag ref (may ingest but not appear in Security -> Code scanning)
            echo "ref=${GITHUB_REF}" >> "$GITHUB_OUTPUT"
            echo "sha=${SHA}" >> "$GITHUB_OUTPUT"
            echo "WARNING: SHA not on default branch; tag uploads may not appear in Code Scanning UI."
          fi

      - name: Debug SARIF path and size
        if: always()
        run: |
          echo "SARIF: ${{ steps.scan.outputs.sarif-path || 'llm-scan-results.sarif' }}"
          ls -la
          wc -c "${{ steps.scan.outputs.sarif-path || 'llm-scan-results.sarif' }}" || true


      - name: Upload SARIF to GitHub Code Scanning
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: ${{ steps.scan.outputs.sarif-path || 'llm-scan-results.sarif' }}
          category: trusys-llm-scan
          ref: ${{ steps.target.outputs.ref }}
          sha: ${{ steps.target.outputs.sha }}
          wait-for-processing: true

      - name: Convert SARIF to CSV
        if: always()
        run: |
          python3 << 'EOF'
          import csv
          import json
          import sys
          sarif_path = "${{ steps.scan.outputs.sarif-path || 'llm-scan-results.sarif' }}"
          csv_path = "llm-scan-results.csv"
          try:
              with open(sarif_path) as f:
                  sarif = json.load(f)
          except FileNotFoundError:
              # No SARIF file (e.g. scan failed); create empty CSV
              with open(csv_path, 'w', newline='') as f:
                  w = csv.writer(f)
                  w.writerow(["rule_id", "level", "message", "file_path", "start_line", "end_line", "start_column", "end_column", "snippet"])
              sys.exit(0)
          rows = []
          for run in sarif.get("runs", []):
              for result in run.get("results", []):
                  rule_id = result.get("ruleId", "")
                  level = result.get("level", "")
                  msg = (result.get("message") or {}).get("text", "")
                  loc = (result.get("locations") or [{}])[0]
                  phys = loc.get("physicalLocation", {})
                  art = phys.get("artifactLocation", {})
                  region = phys.get("region", {})
                  file_path = art.get("uri", "")
                  start_line = region.get("startLine", "")
                  end_line = region.get("endLine", start_line)
                  start_col = region.get("startColumn", "")
                  end_col = region.get("endColumn", "")
                  snippet = (region.get("snippet") or {}).get("text", "").replace("\n", " ").replace('"', '""')
                  rows.append([rule_id, level, msg, file_path, start_line, end_line, start_col, end_col, snippet])
          with open(csv_path, 'w', newline='', encoding='utf-8') as f:
              w = csv.writer(f)
              w.writerow(["rule_id", "level", "message", "file_path", "start_line", "end_line", "start_column", "end_column", "snippet"])
              w.writerows(rows)
          print(f"Wrote {len(rows)} finding(s) to {csv_path}")
          EOF

      - name: Upload CSV as artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: llm-scan-results-csv
          path: llm-scan-results.csv
